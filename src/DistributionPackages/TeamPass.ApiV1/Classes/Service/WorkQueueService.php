<?php

/**
 * NOTICE OF LICENSE
 *
 * This source file is subject to version 3 of the GPL license,
 * that is bundled with this package in the file LICENSE, and is
 * available online at http://www.gnu.org/licenses/gpl.txt
 *
 * PHP version 7
 *
 * @author    Philipp Dittert <philipp.dittert@gmail.com>
 * @copyright 2020 Philipp Dittert <philipp.dittert@gmail.com>
 * @license   http://www.gnu.org/licenses/gpl.txt GNU General Public License, version 3 (GPL-3.0)
 * @link      https://github.com/TeamPass/TeamPass
 */

declare(strict_types=1);

namespace TeamPass\ApiV1\Service;

use Neos\Flow\Persistence\QueryResultInterface;
use TeamPass\Core\Domain\Model\User;
use TeamPass\Core\Domain\Model\WorkQueue;
use Doctrine\Common\Collections\ArrayCollection;
use Neos\Flow\Annotations as Flow;

/**
 * Class WorkQueueService
 *
 * @author    Philipp Dittert <philipp.dittert@gmail.com>
 * @copyright 2020 Philipp Dittert <philipp.dittert@gmail.com>
 * @license   http://www.gnu.org/licenses/gpl.txt GNU General Public License, version 3 (GPL-3.0)
 * @link      https://github.com/TeamPass/TeamPass
 */

class WorkQueueService extends AbstractService
{
    /**
     * Returns all elements in workqueue
     *
     * @return array|object[]
     */
    public function getWork(): object
    {
        return $this->workQueueRepository->findAll();
    }

    /**
     * adds work to a queue
     *
     * @param integer $userId the user id
     *
     * @return void
     * @throws \Exception
     */
    public function addToWorkQueue(int $userId): void
    {
        /** @scrutinizer ignore-call */
        $workQueue = $this->workQueueRepository->findOneByUser($userId);

        // no need to add a user multiple times to the work queue
        if ($workQueue instanceof WorkQueue) {
            throw  new \Exception("User is already in work queue");
        }

        /** @var User $user */
        $user = $this->userRepository->load($userId);

        if (!$user->isEnabled()) {
            throw new \Exception("User is not enabled");
        }

        // don't add to work queue if account setup is not complete (rsa key pair will be generated by user)
        if (!$user->isSetupComplete()) {
            throw new \Exception("User has not finished setup");
        }

        $userAdminFlag = $this->aclRepository->isAdmin($userId, false);

        $totalAmountOfAdmins = $this->userRepository->getTotalAmountOfAdmins(true);

        // check if this user is the first with admin privileges
        if ($totalAmountOfAdmins === 1 && $userAdminFlag === true) {
            throw new \Exception("Application not ready");
        }

        // do not add the user to work queue if there is no admin account (should not happen)
        if ($totalAmountOfAdmins === 0) {
            throw new \Exception("Application not ready");
        }

        $work = new WorkQueue();
        $work->setUser($user);

        $this->workQueueRepository->add($work);
    }

    /**
     * wrapper method for addToWorkQueue. catches all exceptions and only logs the error
     *
     * @param int $userId the user id
     *
     * @return void
     */
    public function addToWorkQueueSilent(int $userId): void
    {
        try {
            $this->addToWorkQueue($userId);
        } catch (\Exception $e) {
            $this->logger->debug(
                "adding user {$userId} to work queue failed, but was silent. Error was: {$e->getMessage()}"
            );
        }
    }

    /**
     * Returns a array containing all work entities in queue
     *
     * @return array
     */
    public function getWorkAsGrid(): array
    {
        $result = array();

        /** @var ArrayCollection $workEntities */
        $workEntities = $this->workQueueRepository->findAll();

        /** @var WorkQueue $workEntity */
        foreach ($workEntities as $workEntity) {
            $ar = array();
            $ar["fullName"] = $workEntity->getUser()->getFullName();
            $ar["workId"] = $workEntity->getWorkQueueId();
            $ar["userId"] = $workEntity->getUser()->getUserId();

            $result[] = $ar;
        }

        return $result;
    }

    /**
     * Returns a array containing all work entities in queue
     *
     * @param int $userId user-id of logged in admin-user
     *
     * @return int
     * @throws \Exception
     */
    public function getWorkCount(int $userId): int
    {
        /** @var User $user */
        $user = $this->userRepository->load($userId);

        // check if admin user is itself in work queue
        /** @var QueryResultInterface $userInWorkQueue */
        /** @scrutinizer ignore-call */
        $userInWorkQueue = $this->workQueueRepository->findByUser($userId);

        if (count($userInWorkQueue->toArray()) !== 0 || !$user->isSetupComplete()) {
            $result = 0;
        } else {
            /** @var array $work */
            $work = $this->workQueueRepository->findAll();
            $result = count($work);
        }

        return $result;
    }

    /**
     * deletes a entity from work queue
     *
     * @param integer $workId the work id to delete
     *
     * @return void
     * @throws \Exception
     */
    public function deleteWorkQueueElement($workId)
    {
        $workQueueItem = $this->workQueueRepository->load($workId);
        $this->workQueueRepository->remove($workQueueItem);
    }

    /**
     * deletes a user from work queue
     *
     * @param integer $userId the user-id to delete from queue
     * @param boolean $strict flag if strict mode should used (strict throws exception if user doesn't exist
     * else return false)
     *
     * @return void
     * @throws \Exception
     */
    public function deleteUserFromWorkQueue(int $userId, bool $strict = true): void
    {
        if ($strict) {
            /** @scrutinizer ignore-call */
            $workQueueEntity = $this->workQueueRepository->findOneByUser($userId);
            $this->workQueueRepository->remove($workQueueEntity);
        } else {
            /** @scrutinizer ignore-call */
            $workQueueEntity = $this->workQueueRepository->findOneByUser($userId);
            if ($workQueueEntity instanceof WorkQueue) {
                $this->workQueueRepository->remove($workQueueEntity);
            }
        }
    }
}
